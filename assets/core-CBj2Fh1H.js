let W=null,X=!1,P=null;async function oe(e){if(W||X)return;if(!P)try{P=await import("./ort.bundle.min-DEoMT0L5.js")}catch(a){console.warn("[YOLO] Failed to import ONNX Runtime:",a),X=!0;return}const t="/imagetool/";try{P.env.wasm.wasmPaths=`${t}node_modules/onnxruntime-web/dist/`,P.env.wasm.numThreads=1,P.env.wasm.simd=!0}catch(a){console.warn("[YOLO] WASM path configuration failed:",a)}const d=`${t}models/yolov8n.onnx`;try{W=await P.InferenceSession.create(d,{executionProviders:["wasm"],enableCpuMemArena:!1})}catch(a){console.warn("[YOLO] Failed to load model:",a),X=!0}}async function re(e,t=.25,d=.45,a={}){if(!W&&!X&&await oe(),!W)return[];const n=640,{width:c,height:o}=e,p=new OffscreenCanvas(c,o);p.getContext("2d").putImageData(e,0,0);const r=new OffscreenCanvas(n,n).getContext("2d");r.drawImage(p,0,0,c,o,0,0,n,n);const g=r.getImageData(0,0,n,n).data,f=new Float32Array(3*n*n);for(let l=0;l<n*n;l++)f[l]=g[l*4]/255,f[l+n*n]=g[l*4+1]/255,f[l+2*n*n]=g[l*4+2]/255;const y=new P.Tensor("float32",f,[1,3,n,n]),V={[W.inputNames[0]]:y};let k;try{k=await W.run(V)}catch(l){return console.warn("[YOLO] Inference failed:",l),[]}const v=k[W.outputNames[0]],w=v.dims[2],I=v.dims[1]-4,x=v.data,z=[],M=[],F=[];for(let l=0;l<w;l++){let A=-1/0,$=-1;for(let s=0;s<I;s++){const u=x[(4+s)*w+l];u>A&&(A=u,$=s)}if(A>t){const s=x[0*w+l],u=x[1*w+l],b=x[2*w+l],C=x[3*w+l],B=s/n*c,G=u/n*o,N=b/n*c,D=C/n*o;z.push([B-N/2,G-D/2,N,D]),M.push(A),F.push($)}}const S=ie(z,M,d),R=[],{minArea:L=1e3,minAspectRatio:_=.25,maxAspectRatio:E=4}=a;for(const l of S){const[A,$,s,u]=z[l],b=s*u,C=s/u;b<L||C<_||C>E||R.push({bbox:[A,$,s,u],score:M[l],classId:F[l]})}return R}function ie(e,t,d){const a=t.map((c,o)=>({s:c,i:o})).sort((c,o)=>o.s-c.s).map(c=>c.i),n=[];for(;a.length>0;){const c=a.shift();n.push(c);for(let o=a.length-1;o>=0;o--)le(e[c],e[a[o]])>=d&&a.splice(o,1)}return n}function le(e,t){const d=e[0]+e[2],a=e[1]+e[3],n=t[0]+t[2],c=t[1]+t[3],o=Math.max(e[0],t[0]),p=Math.max(e[1],t[1]),i=Math.min(d,n),h=Math.min(a,c),r=Math.max(0,i-o)*Math.max(0,h-p),g=e[2]*e[3]+t[2]*t[3]-r;return g===0?0:r/g}let m,Q=null;async function de(){return Q||(Q=new Promise(async(e,t)=>{try{console.log("[OpenCV] Starting initialization...");let d,a;const n=()=>{d&&clearTimeout(d),a&&clearInterval(a)},c=()=>{n(),console.log("[OpenCV] Successfully initialized!"),e()},o=i=>{n(),console.error("[OpenCV] Initialization failed:",i),t(i)};d=setTimeout(()=>{o(new Error("OpenCV initialization timeout after 15 seconds"))},15e3),self.Module={onRuntimeInitialized:()=>{if(console.log("[OpenCV] onRuntimeInitialized callback"),self.cv){m=self.cv,console.log("[OpenCV] Found cv on global scope"),c();return}if(self.Module&&self.Module.matFromImageData){m=self.Module,console.log("[OpenCV] Found cv functions on Module"),c();return}let i=0;a=setInterval(()=>{if(i++,console.log(`[OpenCV] Polling for cv functions... (${i}/100)`),i>100){o(new Error("Polling timeout - cv functions not found"));return}const h=self.Module;h&&h.matFromImageData&&(m=h,console.log("[OpenCV] Found cv functions via polling!"),c())},100)},onAbort:i=>{o(new Error(`OpenCV runtime aborted: ${i}`))}},console.log("[OpenCV] Module object set up, now importing opencv.js...");const p=await import("./opencv-8CN8TSqk.js");if(console.log("[OpenCV] Module imported, keys:",Object.keys(p).sort()),p.cv){m=p.cv,console.log("[OpenCV] Found cv on imported module"),c();return}if(p.default&&typeof p.default=="object"&&p.default.matFromImageData){m=p.default,console.log("[OpenCV] Found cv on default export"),c();return}if(p.matFromImageData){m=p,console.log("[OpenCV] Found cv functions directly on imported module"),c();return}console.log("[OpenCV] Waiting for runtime initialization...")}catch(d){console.error("[OpenCV] Initialization error:",d),t(d)}})),Q}function pe(e){if(!m)throw new Error("OpenCV has not been initialised");if(Array.isArray(e)){const[t,d,a]=e;return new m.Scalar(t,d,a,255)}switch(e){case"white":return new m.Scalar(255,255,255,255);case"transparent":return new m.Scalar(0,0,0,0);default:return new m.Scalar(0,0,0,0)}}async function fe(e,t,d){await de();const[a,n,c,o]=t.map(Math.round),i=new OffscreenCanvas(e.width,e.height).getContext("2d");i.drawImage(e,0,0);const h=i.getImageData(0,0,e.width,e.height),r=m.matFromImageData(h),g=new m.Rect(a,n,c,o),f=r.roi(g),y={};for(const V of d){const{name:k,width:v,height:w,pad:I}=V,x=Math.min(v/f.cols,w/f.rows),z=Math.round(f.cols*x),M=Math.round(f.rows*x),F=new m.Mat;m.resize(f,F,new m.Size(z,M),0,0,m.INTER_AREA);const S=new m.Mat(w,v,m.CV_8UC4);S.setTo(pe(I));const R=S.roi(new m.Rect(Math.floor((v-z)/2),Math.floor((w-M)/2),z,M));F.copyTo(R),R.delete();const L=new ImageData(new Uint8ClampedArray(S.data),v,w);y[k]=await createImageBitmap(L),F.delete(),S.delete()}return f.delete(),r.delete(),y}let q=null,te=!1;async function ue(){if(!te){if(!q)try{q=await import("./index-BVGiUk8Z.js")}catch(e){console.warn("[PSD] Failed to import ag-psd:",e);return}q.initializeCanvas((e,t)=>new OffscreenCanvas(e,t)),te=!0}}async function ne(e,t,d,a=!1){if(!a)return null;await ue();const n=new OffscreenCanvas(e,t);n.getContext("2d").clearRect(0,0,e,t);const o=[{name:"Base",top:0,left:0,canvas:n,opacity:0,visible:!1},...d.map(r=>{const f=me(r.image);return{name:r.name,top:r.top??0,left:r.left??0,canvas:f,opacity:255,visible:!0}})],p=new OffscreenCanvas(e,t),i=p.getContext("2d");i.fillStyle="#FFFFFF",i.fillRect(0,0,e,t);for(const r of d)i.drawImage(r.image,r.left??0,r.top??0);const h=q.writePsd({width:e,height:t,children:o,canvas:p},{generateThumbnail:!0});return new Blob([h],{type:"image/vnd.adobe.photoshop"})}function me(e){const t=new OffscreenCanvas(e.width,e.height);return t.getContext("2d").drawImage(e,0,0),t}self.onmessage=async e=>{var d,a,n,c;const t=e.data;switch(t.type){case"init":await oe(),postMessage({type:"progress",step:"init"});break;case"detect":{const{fileId:o,imageData:p}=t.payload;try{const i=await re(p);postMessage({type:"progress",step:"detect",fileId:o}),postMessage({type:"detect",fileId:o,predictions:i})}catch(i){postMessage({type:"progress",step:"detect",fileId:o}),postMessage({type:"detect",fileId:o,predictions:[]}),console.warn("[worker] detect failed:",i)}break}case"compose":{const{image:o,bbox:p,sizes:i,exportPsd:h}=t.payload,r=await fe(o,p,i);postMessage({type:"progress",step:"opencv"});const g=Object.entries(r).map(([y,V])=>({name:y,image:V}));postMessage({type:"progress",step:"compose"});const f=await ne(o.width,o.height,g,h);postMessage({type:"progress",step:"psd"}),postMessage({type:"compose",images:r,psd:f});break}case"composeMany":{const{groups:o,profiles:p,layouts:i}=t.payload;console.log("[Worker] Starting composeMany:",o.length,"groups",p.length,"profiles");const h=[];for(const r of o)for(const g of p){const[f,y]=g.size.split("x").map(s=>parseInt(s,10)),V=y>f?"vertical":f>y?"horizontal":"square",k=i&&i[V]||{gutter:0,bg_color:"#FFFFFF",patterns:{}},v=(d=k.patterns)==null?void 0:d[String(r.images.length)];console.log(`[Worker] ${r.name}_${g.tag}: ${f}x${y} → ${V}, ${r.images.length} images → pattern:`,v==null?void 0:v.rows);const w=g.formats||[];if(w.length===0){console.log(`[Worker] Skipping profile "${g.tag}" - no formats selected`);continue}let I;if(v&&Array.isArray(v.rows))I=v.rows;else{const s=r.images.length,u=Math.ceil(Math.sqrt(s)),b=Math.ceil(s/u);I=Array.from({length:b},(C,B)=>B<b-1?u:s-u*(b-1)||u)}const x=k.gutter??0,z=k.bg_color??"#FFFFFF",M=new OffscreenCanvas(f,y),F=M.getContext("2d");F.fillStyle=z,F.fillRect(0,0,f,y);const S=[],R=x*(I.length-1),L=y-R;let _=0,E=0;for(let s=0;s<I.length;s++){const u=I[s],b=s===I.length-1;let C;b?C=y-_:C=Math.floor(L/I.length);const B=x*(u-1),G=f-B,N=Math.floor(G/u);let D=0;for(let U=0;U<u;U++){const O=r.images[E];if(!O)break;const se=U===u-1;let T;se?T=f-D:T=N;const H=T/C,Z=O.width/O.height;let J=0,K=0,Y=O.width,j=O.height;if(Z>H?(Y=Math.round(O.height*H),J=Math.round((O.width-Y)/2)):Z<H&&(j=Math.round(O.width/H),K=Math.round((O.height-j)/2)),F.drawImage(O,J,K,Y,j,D,_,T,C),w.includes("psd")){const ee=new OffscreenCanvas(T,C);ee.getContext("2d").drawImage(O,J,K,Y,j,0,0,T,C);const ae=await createImageBitmap(await ee.convertToBlob()),ce=((a=r.filenames)==null?void 0:a[E])||`Image_${E+1}`;S.push({name:ce,image:ae,left:D,top:_})}D+=T+x,E++}_+=C+x}const l=await((n=M.convertToBlob)==null?void 0:n.call(M).then(s=>createImageBitmap(s)).catch(async()=>{const s=document.createElement("canvas");s.width=f,s.height=y,s.getContext("2d").drawImage(M,0,0);const b=await new Promise(C=>s.toBlob(B=>C(B),"image/png"));return createImageBitmap(b)}));let A=null,$=null;if(w.includes("psd")&&S.length>0&&(A=await ne(f,y,S,!0)),w.includes("png")){const s=new OffscreenCanvas(l.width,l.height);s.getContext("2d").drawImage(l,0,0),$=await((c=s.convertToBlob)==null?void 0:c.call(s,{type:"image/png"}))||null}h.push({filename:`${r.name}_${g.tag}`,image:l,psd:A||void 0,png:$||void 0,formats:w})}console.log("[Worker] Sending composeMany result:",h.length,"outputs"),postMessage({type:"composeMany",outputs:h});break}}};
