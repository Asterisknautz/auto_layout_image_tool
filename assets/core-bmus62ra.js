let e,t=null,o=!1,n=null;async function a(e){if(t||o)return;if(!n)try{n=await import("./ort.bundle.min-DlsPDSSP.js")}catch(i){return console.warn("[YOLO] Failed to import ONNX Runtime:",i),void(o=!0)}const a="/imagetool/";try{n.env.wasm.wasmPaths=`${a}node_modules/onnxruntime-web/dist/`,n.env.wasm.numThreads=1,n.env.wasm.simd=!0}catch(i){console.warn("[YOLO] WASM path configuration failed:",i)}const s=`${a}models/yolov8n.onnx`;try{t=await n.InferenceSession.create(s,{executionProviders:["wasm"],enableCpuMemArena:!1})}catch(i){console.warn("[YOLO] Failed to load model:",i),o=!0}}async function s(e,s=.25,r=.45,l={}){if(t||o||await a(),!t)return[];const c=640,{width:d,height:p}=e,g=new OffscreenCanvas(d,p);g.getContext("2d").putImageData(e,0,0);const m=new OffscreenCanvas(c,c).getContext("2d");m.drawImage(g,0,0,d,p,0,0,c,c);const u=m.getImageData(0,0,c,c).data,f=new Float32Array(1228800);for(let t=0;t<409600;t++)f[t]=u[4*t]/255,f[t+409600]=u[4*t+1]/255,f[t+819200]=u[4*t+2]/255;const h=new n.Tensor("float32",f,[1,3,c,c]),w={[t.inputNames[0]]:h};let v;try{v=await t.run(w)}catch(z){return console.warn("[YOLO] Inference failed:",z),[]}const y=v[t.outputNames[0]],M=y.dims[2],C=y.dims[1]-4,O=y.data,I=[],F=[],b=[];for(let t=0;t<M;t++){let e=-1/0,o=-1;for(let n=0;n<C;n++){const a=O[(4+n)*M+t];a>e&&(e=a,o=n)}if(e>s){const n=O[0*M+t]/c*d,a=O[1*M+t]/c*p,s=O[2*M+t]/c*d,i=O[3*M+t]/c*p;I.push([n-s/2,a-i/2,s,i]),F.push(e),b.push(o)}}const x=function(e,t,o){const n=t.map((e,t)=>({s:e,i:t})).sort((e,t)=>t.s-e.s).map(e=>e.i),a=[];for(;n.length>0;){const t=n.shift();a.push(t);for(let a=n.length-1;a>=0;a--)i(e[t],e[n[a]])>=o&&n.splice(a,1)}return a}(I,F,r),V=[],{minArea:A=1e3,minAspectRatio:S=.25,maxAspectRatio:k=4}=l;for(const t of x){const[e,o,n,a]=I[t],s=n/a;n*a<A||(s<S||s>k||V.push({bbox:[e,o,n,a],score:F[t],classId:b[t]}))}return V}function i(e,t){const o=e[0]+e[2],n=e[1]+e[3],a=t[0]+t[2],s=t[1]+t[3],i=Math.max(e[0],t[0]),r=Math.max(e[1],t[1]),l=Math.min(o,a),c=Math.min(n,s),d=Math.max(0,l-i)*Math.max(0,c-r),p=e[2]*e[3]+t[2]*t[3]-d;return 0===p?0:d/p}let r=null;function l(t){if(!e)throw new Error("OpenCV has not been initialised");if(Array.isArray(t)){const[o,n,a]=t;return new e.Scalar(o,n,a,255)}return"white"===t?new e.Scalar(255,255,255,255):new e.Scalar(0,0,0,0)}async function c(t,o,n){await async function(){return r||(r=new Promise(async(t,o)=>{try{let n,a;console.log("[OpenCV] Starting initialization...");const s=()=>{n&&clearTimeout(n),a&&clearInterval(a)},i=()=>{s(),console.log("[OpenCV] Successfully initialized!"),t()},r=e=>{s(),console.error("[OpenCV] Initialization failed:",e),o(e)};n=setTimeout(()=>{r(new Error("OpenCV initialization timeout after 15 seconds"))},15e3),self.Module={onRuntimeInitialized:()=>{if(console.log("[OpenCV] onRuntimeInitialized callback"),self.cv)return e=self.cv,console.log("[OpenCV] Found cv on global scope"),void i();if(self.Module&&self.Module.matFromImageData)return e=self.Module,console.log("[OpenCV] Found cv functions on Module"),void i();let t=0;a=setInterval(()=>{if(t++,console.log(`[OpenCV] Polling for cv functions... (${t}/100)`),t>100)return void r(new Error("Polling timeout - cv functions not found"));const o=self.Module;o&&o.matFromImageData&&(e=o,console.log("[OpenCV] Found cv functions via polling!"),i())},100)},onAbort:e=>{r(new Error(`OpenCV runtime aborted: ${e}`))}},console.log("[OpenCV] Module object set up, now importing opencv.js...");const l=await import("./opencv-Bru78Xdn.js");if(console.log("[OpenCV] Module imported, keys:",Object.keys(l).sort()),l.cv)return e=l.cv,console.log("[OpenCV] Found cv on imported module"),void i();if(l.default&&"object"==typeof l.default&&l.default.matFromImageData)return e=l.default,console.log("[OpenCV] Found cv on default export"),void i();if(l.matFromImageData)return e=l,console.log("[OpenCV] Found cv functions directly on imported module"),void i();console.log("[OpenCV] Waiting for runtime initialization...")}catch(n){console.error("[OpenCV] Initialization error:",n),o(n)}})),r}();const[a,s,i,c]=o.map(Math.round),d=new OffscreenCanvas(t.width,t.height).getContext("2d");d.drawImage(t,0,0);const p=d.getImageData(0,0,t.width,t.height),g=e.matFromImageData(p),m=new e.Rect(a,s,i,c),u=g.roi(m),f={};for(const r of n){const{name:t,width:o,height:n,pad:a}=r,s=Math.min(o/u.cols,n/u.rows),i=Math.round(u.cols*s),c=Math.round(u.rows*s),d=new e.Mat;e.resize(u,d,new e.Size(i,c),0,0,e.INTER_AREA);const p=new e.Mat(n,o,e.CV_8UC4);p.setTo(l(a));const g=p.roi(new e.Rect(Math.floor((o-i)/2),Math.floor((n-c)/2),i,c));d.copyTo(g),g.delete();const m=new ImageData(new Uint8ClampedArray(p.data),o,n);f[t]=await createImageBitmap(m),d.delete(),p.delete()}return u.delete(),g.delete(),f}let d=null,p=!1;async function g(e,t,o,n=!1){if(!n)return null;await async function(){if(!p){if(!d)try{d=await import("./index-BrOV7B05.js")}catch(e){return void console.warn("[PSD] Failed to import ag-psd:",e)}d.initializeCanvas((e,t)=>new OffscreenCanvas(e,t)),p=!0}}();const a=new OffscreenCanvas(e,t);a.getContext("2d").clearRect(0,0,e,t);const s=[{name:"Base",top:0,left:0,canvas:a,opacity:0,visible:!1},...o.map(e=>{const t=function(e){const t=new OffscreenCanvas(e.width,e.height);return t.getContext("2d").drawImage(e,0,0),t}(e.image);return{name:e.name,top:e.top??0,left:e.left??0,canvas:t,opacity:255,visible:!0}})],i=new OffscreenCanvas(e,t),r=i.getContext("2d");r.fillStyle="#FFFFFF",r.fillRect(0,0,e,t);for(const c of o)r.drawImage(c.image,c.left??0,c.top??0);const l=d.writePsd({width:e,height:t,children:s,canvas:i},{generateThumbnail:!0});return new Blob([l],{type:"image/vnd.adobe.photoshop"})}self.onmessage=async e=>{var t,o,n,i;const r=e.data;switch(r.type){case"init":await a(),postMessage({type:"progress",step:"init"});break;case"detect":{const{fileId:e,imageData:t}=r.payload;try{const o=await s(t);postMessage({type:"progress",step:"detect",fileId:e}),postMessage({type:"detect",fileId:e,predictions:o})}catch(l){postMessage({type:"progress",step:"detect",fileId:e}),postMessage({type:"detect",fileId:e,predictions:[]}),console.warn("[worker] detect failed:",l)}break}case"compose":{const{image:e,bbox:t,sizes:o,exportPsd:n}=r.payload,a=await c(e,t,o);postMessage({type:"progress",step:"opencv"});const s=Object.entries(a).map(([e,t])=>({name:e,image:t}));postMessage({type:"progress",step:"compose"});const i=await g(e.width,e.height,s,n);postMessage({type:"progress",step:"psd"}),postMessage({type:"compose",images:a,psd:i});break}case"composeMany":{const{groups:e,profiles:a,layouts:s}=r.payload;console.log("[Worker] Starting composeMany:",e.length,"groups",a.length,"profiles");const l=[];for(const r of e)for(const e of a){const[a,c]=e.size.split("x").map(e=>parseInt(e,10)),d=c>a?"vertical":a>c?"horizontal":"square",p=s&&s[d]||{gutter:0,bg_color:"#FFFFFF",patterns:{}},m=null==(t=p.patterns)?void 0:t[String(r.images.length)];console.log(`[Worker] ${r.name}_${e.tag}: ${a}x${c} → ${d}, ${r.images.length} images → pattern:`,null==m?void 0:m.rows);const u=e.formats||[];if(0===u.length){console.log(`[Worker] Skipping profile "${e.tag}" - no formats selected`);continue}let f;if(m&&Array.isArray(m.rows))f=m.rows;else{const e=r.images.length,t=Math.ceil(Math.sqrt(e)),o=Math.ceil(e/t);f=Array.from({length:o},(n,a)=>a<o-1?t:e-t*(o-1)||t)}const h=p.gutter??0,w=p.bg_color??"#FFFFFF",v=new OffscreenCanvas(a,c),y=v.getContext("2d");y.fillStyle=w,y.fillRect(0,0,a,c);const M=[],C=h*(f.length-1),O=c-C;let I=0,F=0;for(let e=0;e<f.length;e++){const t=f[e];let n;n=e===f.length-1?c-I:Math.floor(O/f.length);const s=a-h*(t-1),i=Math.floor(s/t);let l=0;for(let e=0;e<t;e++){const s=r.images[F];if(!s)break;let c;c=e===t-1?a-l:i;const d=c/n,p=s.width/s.height;let g=0,m=0,f=s.width,w=s.height;if(p>d?(f=Math.round(s.height*d),g=Math.round((s.width-f)/2)):p<d&&(w=Math.round(s.width/d),m=Math.round((s.height-w)/2)),y.drawImage(s,g,m,f,w,l,I,c,n),u.includes("psd")){const e=new OffscreenCanvas(c,n);e.getContext("2d").drawImage(s,g,m,f,w,0,0,c,n);const t=await createImageBitmap(await e.convertToBlob()),a=(null==(o=r.filenames)?void 0:o[F])||`Image_${F+1}`;M.push({name:a,image:t,left:l,top:I})}l+=c+h,F++}I+=n+h}const b=await(null==(n=v.convertToBlob)?void 0:n.call(v).then(e=>createImageBitmap(e)).catch(async()=>{const e=document.createElement("canvas");e.width=a,e.height=c;e.getContext("2d").drawImage(v,0,0);const t=await new Promise(t=>e.toBlob(e=>t(e),"image/png"));return createImageBitmap(t)}));let x=null,V=null;if(u.includes("psd")&&M.length>0&&(x=await g(a,c,M,!0)),u.includes("png")){const e=new OffscreenCanvas(b.width,b.height);e.getContext("2d").drawImage(b,0,0),V=await(null==(i=e.convertToBlob)?void 0:i.call(e,{type:"image/png"}))||null}l.push({filename:`${r.name}_${e.tag}`,image:b,psd:x||void 0,png:V||void 0,formats:u})}console.log("[Worker] Sending composeMany result:",l.length,"outputs"),postMessage({type:"composeMany",outputs:l});break}}};
